%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[paper=a4, fontsize=11pt]{scrartcl} % A4 paper and 11pt font size

\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\usepackage{fourier} % Use the Adobe Utopia font for the document - comment this line to return to the LaTeX default
\usepackage[english]{babel} % English language/hyphenation
\usepackage{amsmath,amsfonts,amsthm} % Math packages

\usepackage{indentfirst} 
\usepackage{listings}
\usepackage{syntax}

\usepackage{sectsty} % Allows customizing section commands
\allsectionsfont{\centering \normalfont\scshape} % Make all sections centered, the default font and small caps

\usepackage{fancyhdr} % Custom headers and footers
\pagestyle{fancyplain} % Makes all pages in the document conform to the custom headers and footers
\fancyhead{} % No page header - if you want one, create it in the same way as the footers below
\fancyfoot[L]{} % Empty left footer
\fancyfoot[C]{} % Empty center footer
\fancyfoot[R]{\thepage} % Page numbering for right footer
\renewcommand{\headrulewidth}{0pt} % Remove header underlines
\renewcommand{\footrulewidth}{0pt} % Remove footer underlines
\setlength{\headheight}{13.6pt} % Customize the height of the header

\numberwithin{equation}{section} % Number equations within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{figure}{section} % Number figures within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)
\numberwithin{table}{section} % Number tables within sections (i.e. 1.1, 1.2, 2.1, 2.2 instead of 1, 2, 3, 4)

\setlength\parindent{0pt} % Removes all indentation from paragraphs - comment this line for an assignment with lots of text

%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} % Create horizontal rule command with 1 argument of height

\title{	
\normalfont \normalsize 
\textsc{CS 6110 Final Report, University of Utah} \\ [25pt] % Your university, school and/or department name(s)
\horrule{0.5pt} \\[0.4cm] % Thin top horizontal rule
\huge Verifying Contracts for Dynamic Typing Language \\ % The assignment title
\horrule{2pt} \\[0.5cm] % Thick bottom horizontal rule
}

\author{Guannan Wei, Jian Lan} % Your name

\date{\normalsize\today} % Today's date or a custom date

\begin{document}

\maketitle % Print the title

\section{Introduction}

This project presents a method to verify contract of functions in dynamic typing programming languages via abstract interpretation. \\

\textbf{Motivation}

Many popular languages such as Python, Perl, Ruby, JavaScript and Scheme are dynamic typing, which means the type of value of an identifier may change in runtime, and the type checkings are performed in runtime rather than compile-time. This feature helps programmers to build prototype rapidly because programmers don't need to firstly write type annotations and make the annotations be accepted by type checker.

But dynamic typing also makes program much easier to have bugs since programmer can not catch errors until it raised in runtime. For example, as Figure \ref{fig1} shows, the function \texttt{add1} executes a simple arithmetic operation that adds \texttt{1} to \texttt{x}. But if we pass a string argument \texttt{"3"} to \texttt{add1}, the type error \textit{only} will be raised when program runs to that call site.

\begin{figure}[h!]
\lstset{language=Lisp}
\begin{lstlisting}[frame=single]
(define (add1 x) (+ x 1)) ;Defining a function
(add1 3)                  ;OK
(add1 "3")                ;Error
\end{lstlisting} 
\caption{A Scheme example}
\label{fig1}
\end{figure}

Modern languages such as Racket, a dialect of Scheme provide a way to ease this problem: programmers can write contract for function, then the language's contract system will check the argument and returned value is satified these contracts or not in runtime(TODO: REF). The contracts are just composed of ordinary functions in the language that return a boolean value, and the way of checking contract is to straightforwardly interpret these function with runtime value, if it returns \texttt{true} then it satisfies the contract, otherwise the contract system will properly blame somewhere violates the contract.

Contract provides a way to describe refined behavior of a function, and programmers can utilize contract system and write test cases to syntatically cover the program to find bugs early, but the drawback is it may involve additional performance cost in runtime because contract checking happends on each function application.

The motivation of our project is we don't want to lose the advantages of dynamic typing, but we also want to write correct programs and catch errors as early as possible, for example, before running the program. So we present a method to check contracts statically in dynamic typing languages. \\

\textbf{Approach}

Our approach is based on abstracting abstract machine(TODO: REF), which is a technique that using abstract machine such as CESK machine (TODO: REF) to do abstract interpretation by transforming concrete semantics to abstract semantics. 

The key idea of our approach is regarding predicate (i.e. the contract) as abstract value. A predicate is an approximation of a value, it descirbes the bound of the value. We build an non-deterministic abstract interpreter that do computations on these abstract values, the term \textit{non-deterministic} means it will explore every possible behaviors of program's runtime. The abstract interpretation is sound, which means if the input of abstract interpretation is a sound approximation of concrete value, it's guaranteed that the result of abstract interpretation is still a sound approximation of returned concrete value. So that we could leverage abstract interpretation to check the behaviors of a function that depicted by contracts.

Section 2 describes basic setting of the language, introduces the concrete semantics and abstract semantics of our abstracting abstract machine.

Section 3 TODO. \\

At last, I would like to explain the reason why we change the project name. At the very beginning, we propose our project as \textit{Extending Scheme with Liquid Type}, where Liquid Type is the abbreviation of \textit{Logically Qualified Data Types}. Liquid Type is a type system based on Hindley-Milner type with predicate abstraction and could infer the refinement part of a type(TODO: REF). It's a powerful type system that can help programmers to write pre-condition and post-condition of a function, and catch erros before running the program. But later, as we go further in this project, we realized that in such context of dynamic typing functional programming languages, \textit{contract} is a more precise and conventional term to describe the pre-conditions and post-conditions. And what we are doing is actually verifying these contracts statically, i.e. without really running the program. Yet, the techniques behind the title does not change.

%----------------------------------------------------------------------------------------

\section{Abstracting Abstract Machine}

%------------------------------------------------

\subsection{Abstract Interpretation}

%------------------------------------------------

\subsection{The Language}

We construct an small-step abstract interpreter for a small language which is a variant of call-by-value \textit{A-Normal Form}(TODO: REF). Traditionally A-Normal Form used is an intermediate representation of functional program as an alternative choice of Continuation-Passing Style (CPS) in compiler, it has several settings to simplify compiler as well as interpreter for our project, and more importantly, it's much more human-readable compared with CPS form. Programs in direct style can be easily transformed into A-Normal Form(TODO: REF).

The Figure \ref{fig2} shows the syntax of our tiny language in BNF.

\begin{figure}[h!]
\setlength{\grammarparsep}{7pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{8em} % increase separation between LHS/RHS 
\begin{grammar}
<var> ::= <symbol>

<label> ::= <symbol>

<integer> ::= $\cdots$ | \texttt{-1} | \texttt{0} | \texttt{1} | $\cdots$

<boolean> ::= \texttt{true} | \texttt{false}

<lambda> ::= (\texttt{lambda} [<label>] (<var>) <exp>)

<aexp> ::= <lambda>
\alt <var>
\alt <integer>
\alt <boolean>
\alt (<prim> <aexp>*)

<cexp> ::= (<aexp> <aexp>)
\alt (\texttt{if} <aexp> <exp> <exp>)
\alt (\texttt{letrec} ((<var> <aexp>)) <exp>)

<exp> ::= <aexp>
\alt <cexp>
\alt (\texttt{let} ((<var> <exp>)) <exp>)

<prim> ::= \texttt{+} | \texttt{-} | \texttt{*} | \texttt{=} | \texttt{and} | \texttt{or} | \texttt{not}
\end{grammar}
\caption{Syntax of ANF}
\label{fig2}
\end{figure}

Not surprisingly, we use \texttt{lambda} to form a function, and \textit{<label>} is optional and mainly used for debugging. And the language has two primitive data types: integer and boolean, as well as primitive operations on these data type are provided. ANF has three kind of expressions:

\begin{itemize}
\item Atomic expressions (\textit{<aexp>}) include primitive values, functions, and operations on prmitive values. Evaluating these expressions are all trivial, that is immediately and always terminate, and no side effect.

\item Complex expressions (\textit{<cexp>}) are function applications, \texttt{if} expression and \texttt{letrec} expression. A notable thing is the operand and operator of an application must be an atomic expression, and as well as the condition of \texttt{if} expression and the right hand side of \texttt{lecrec} binding. Complex expression may not terminate, for example, an infinite recursive application.

\item Expressions (\textit{<exp>}) are either atomic expression, complex expression or a \texttt{let} expression. Unlike \texttt{letrec}, the right hand side of \texttt{let} binding can be a <exp>, so all non-trivial expressions must be bound by a \texttt{let} expression.
\end{itemize}

%------------------------------------------------

\subsection{CESK Machine}

This section we will introduce the CESK Machine(TODO: REF) and its concrete semantics for ANF.

%------------------------------------------------

\subsection{Abstracting CESK Machine}

%----------------------------------------------------------------------------------------

\section{Verifying Contracts}

%----------------------------------------------------------------------------------------

\section{Implementation}

To verify our approach, we implemented a prototype verifier for ANF in Racket language.

\subsection{AAM}
Store widening.

\subsection{Contract}

%----------------------------------------------------------------------------------------

\section{Examples}

%----------------------------------------------------------------------------------------

\section{Related Work}

%----------------------------------------------------------------------------------------

\section{Future Work}

\section{Conclusion}

\end{document}
